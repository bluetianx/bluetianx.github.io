<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>探索Asp net core3中的 项目文件、Program.cs和通用host（译）</title>
      <link href="/2019/08/31/exploringaspnetcore3/"/>
      <url>/2019/08/31/exploringaspnetcore3/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><a href="https://andrewlock.net/exploring-the-new-project-file-program-and-the-generic-host-in-asp-net-core-3/" target="_blank" rel="noopener">原文地址</a></p><p>在这篇博客中我将探索一些关于Asp.net core 3.0应用的基础功能——.csproj 项目文件和Program源文件。我将会描述他们从asp.net core 2.X在默认模版中是怎样改变的，以及探讨Aspnetcore3.0使用的Api的变化。</p><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>.Net core 3.0 会在九月23号的 <a href="https://www.dotnetconf.net/" target="_blank" rel="noopener">NET Conf</a>上发布，但现在已经有一个支持的预览版本（Preview 8）。最新的预览版本与最终发布版本不可能有太多的变化，所以现在是开始尝试和查看3.0增加的功能的好时机。</p><p>Net core 3.0主要的更新是把windows桌面应用运行了Net core 上，但是Asp Net core 也增加了很多东西。也许最大的新特性就是<a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-3.0#server-side" target="_blank" rel="noopener">服务端Blazor</a>(我个人最感兴趣的是客户端的版本，但是现在还不可用)，但是也有一些迭代的改变和新特性加入了Asp Net Core。</p><p>在这篇博客中，我将探索一些关于非常 “基础” 的更新。</p><ul><li><a href="https://andrewlock.net/the-microsoft-aspnetcore-all-metapackage-is-huge-and-thats-awesome-thanks-to-the-net-core-runtime-store-2" target="_blank" rel="noopener">Microsoft.AspNetCore.App metapackage</a>在nuget已经不再可用</li><li>Asp net core 已经选择 <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0" target="_blank" rel="noopener">GnericHost</a> 来取代 <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/web-host?view=aspnetcore-3.0" target="_blank" rel="noopener">WebHost</a></li></ul><blockquote><p>如果你打算把Asp net Core 2.X 软件迁移到3.0 ，一定要查阅<a href="https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30" target="_blank" rel="noopener">迁移指南</a></p></blockquote><p>在这篇博客中，当你创建一个新的Asp Net core应用时，比如 你用dotnet new webapi，我将探索.csproj 文件和Program.cs文件。在文章的最后，我将比较StartUp文件相对于2.X版本是怎样变化的，以及Asp Net core 中使用中的模版有什么不同（比如 web，webapi，mvc）</p><hr><h2 id="新项目文件与共享框架的变化"><a href="#新项目文件与共享框架的变化" class="headerlink" title="新项目文件与共享框架的变化"></a>新项目文件与共享框架的变化</h2><p>当你创建完一个新的Asp Net core项目，然后打开.csproj文件，它基本上是如下的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;PropertyGroup&gt;</span><br><span class="line">    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;</span><br><span class="line">  &lt;/PropertyGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Project&gt;</span><br></pre></td></tr></table></figure><p>如果你与Asp net core 2.X的项目文件做比较，主要有如下的相同点和不同点</p><ul><li><code>&lt;TargetFramework&gt;</code> 不再是netcoreapp2.1或者2.2 ，而是netcoreapp3.0了，这是因为我们把目标框架2.1/2.2 替换成了3.0</li><li><code>&lt;Project&gt;</code> 元素仍然是 Microsoft.Net.Sdk.Web，虽然已经更新成了ASP.NET Core 3.0,但是你的项目文件中的语法仍然是没有变化</li><li>Microsoft.AspNetCore.App meta 包已经不存在。</li></ul><p>这里的最后一个有意思的变更。在我<a href="https://andrewlock.net/exploring-the-microsoft-aspnetcore-app-shared-framework-in-asp-net-core-2-1-preview-1/" target="_blank" rel="noopener">之前的博客</a>中提到，在Asp Net core2.X你引用一个名叫Microsoft.AspNetCore.App的共享框架元数据包。这个共享框架提供了大量的好处，比如避免你在你的应用中手动安装所有的独立的程序包以及允许你使用 运行时的向前滚动更新的特性。</p><p>在Asp Net core3.0中，微软已经不再以Nuget元数据包的形式发布这个共享框架，也不存在3.0.0版本的Microsoft.AspNetCore.App。这个共享框架仍然和以前一样通过Net core 安装，但是在3.0中你的使用略有不同。</p><p>在Asp Net core2.X 中，为了引用这个共享框架，你会添加如下代码到你的项目文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">  &lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; /&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><p>相反，在3.0中你要使用 <code>&lt;FrameworkReference&gt;</code> 元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">  &lt;FrameworkReference Include=&quot;Microsoft.AspNetCore.App&quot; /&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><p>“但是停一下”，你说：“为什么我的Asp Net Core 项目文件没有这个？”<br>这是个好问题，答案是 <code>Microsoft.Net.Sdk.Web</code> 默认包含了。</p><hr><h2 id="不再有用于共享框架组件的包"><a href="#不再有用于共享框架组件的包" class="headerlink" title="不再有用于共享框架组件的包"></a>不再有用于共享框架组件的包</h2><p>在3.0中另外一个最大的变更是你<a href="https://github.com/aspnet/AspNetCore/issues/3756">不再需要独立安装共享框架的其他部分的Nuget程序包了</a>。例如，在Asp Net Core 2.X中，你可以用 像 Microsoft.AspNetCore.Authentication或Microsoft.AspNetCore.Authentication这样的独立的程序包来替换依赖于整个框架的程序包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">  &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication&quot; Version=&quot;2.1.0&quot;/&gt;</span><br><span class="line">  &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Identity&quot; Version=&quot;2.1.0&quot;/&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><p>这通常对库最有用，因为应用程序总是需要依赖于共享框架。然而，在 Net Core3.0中，这一切都不可能了。这些Nuget包不会在发布了。相反，如果你需要在你的项目中引用其中的类库，你必须添加这个 <code>&lt;FrameworkReference&gt;</code> <a href="https://github.com/DamianEdwards/TagHelperPack/blob/master/src/TagHelperPack/TagHelperPack.csproj">元素到你的项目中</a></p><p>例如EF Core和social authentication providers 这些程序包中另外一个需要注意的事情是它们也不再是<a href="https://github.com/aspnet/AspNetCore/issues/3755">共享框架的一部分了</a>，如果你需要使用这些程序包，你必须手动从nuget上安装到你的项目中。</p><blockquote><p>对于这些程序包的完整清单，查阅这个<a href="https://github.com/aspnet/AspNetCore/issues/3755">Github issue</a></p></blockquote><hr><h2 id="Program-cs-文件从-2-X到-3-0的变化"><a href="#Program-cs-文件从-2-X到-3-0的变化" class="headerlink" title="Program.cs 文件从 2.X到 3.0的变化"></a>Program.cs 文件从 2.X到 3.0的变化</h2><p>Asp Net Core 3.0中的Proram.cs文件第一眼看上去与2.X版本的非常相似。但是已经有许多类型发生了改变，这是因为在Net Core 3.0中，<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0" target="_blank" rel="noopener">Asp Net Core为了运行在通用host上已经进行了重新构建</a>,使用独立的<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/web-host?view=aspnetcore-3.0" target="_blank" rel="noopener">Web Host</a>已经被替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        CreateHostBuilder(args).Build().Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;</span><br><span class="line">        Host.CreateDefaultBuilder(args)</span><br><span class="line">            .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通用Host是从2.1版本被发布的，这是个非常好的想法，但是我发现关于它的<a href="https://andrewlock.net/the-asp-net-core-generic-host-namespace-clashes-and-extension-methods/" target="_blank" rel="noopener">各种问题</a>,主要问题是它<a href="https://andrewlock.net/adding-serilog-to-the-asp-net-core-generic-host/" target="_blank" rel="noopener">为类库产生了太多的工作</a>,值得庆幸的是，3.0中的这一变化应该可以解决这些问题。</p></blockquote><p>很大程度上，这个变化产生的最终结果是和你过去使用的Net Core2.X版本基本相似，但是用于配置你的app的全部配置的方法<code>WebHost.CreateDefaultBuilder()</code> 被替换成了两个逻辑步骤，这个两个独立的方法叫做：</p><ul><li><p><code>Host.CreateDefaultBuilder()</code> ，负责配置你的app配置、日志以及依赖注入容器</p></li><li><p><code>IHostBuilder.ConfigureWebHostDefaults()</code> ,负责为经典的Asp Net Core 应用添加所需要的所有东西，比如：配置Kestrel和使用一个 Startup.cs用于配置你的DI容器和中间件管道</p></li></ul><hr><h2 id="通用Host-builder"><a href="#通用Host-builder" class="headerlink" title="通用Host builder"></a>通用Host builder</h2><p>正如我之前说的那样，通用Host为Asp Net core 3.0的构建提供了基础。它同样也提供了你先前在Asp Net core应用中使用的基础性的Microsoft.Extensions.* 元素，比如：日志、配置和依赖注入。</p><p>下面的代码是一个简化版本的 <code>Host.CreateDefaultBuilder()</code> <a href="https://github.com/aspnet/Extensions/blob/7005708d7a26e5f6ed4bcb0271f052241033b8a6/src/Hosting/Hosting/src/Host.cs">方法</a>。它和2.X版本的  <code>WebHost.CreateDefaultBuilder()</code> 作用一样。但是我会简短说一下值得关注的变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static IHostBuilder CreateDefaultBuilder(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var builder = new HostBuilder();</span><br><span class="line"></span><br><span class="line">    builder.UseContentRoot(Directory.GetCurrentDirectory());</span><br><span class="line">    builder.ConfigureHostConfiguration(config =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // Uses DOTNET_ environment variables and command line args</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    builder.ConfigureAppConfiguration((hostingContext, config) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // JSON files, User secrets, environment variables and command line arguments</span><br><span class="line">    &#125;)</span><br><span class="line">    .ConfigureLogging((hostingContext, logging) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // Adds loggers for console, debug, event source, and EventLog (Windows only)</span><br><span class="line">    &#125;)</span><br><span class="line">    .UseDefaultServiceProvider((context, options) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // Configures DI provider validation</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，这个<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0#default-builder-settings" target="_blank" rel="noopener">方法与2.X版本</a>的不同点如下：</p><ul><li>Hosting配置使用以 <code>DOTNET_</code> 为前缀的环境变量</li><li>Hosting配置使用命令行变量</li><li>增加了 <code>EventSourceLogger</code> 和 <code>EventLogLogger</code> 日志提供者</li><li>可以选择使用ServiceProvider验证功能</li><li>没有关于Web Hosting 的特定配置</li></ul><p>第一个有意思的地方就是Host配置是如何设置的。对于Web Host而言，默认使用以 <code>ASPNETCORE_</code> 为前缀的环境变量作为配置。所以设置<code>ASPNETCORE_ENVIRONMENT</code> 环境变量将会设置 <code>Environment</code> 配置的值。对于 通用Host来说，这个前缀现在是<code>DOTNET_</code> ,和传给应用运行时的任意命令行参数。</p><blockquote><p>这个host配置起的作用好比是决定你的应用运行在什么的主机环境，host配置与你应用配置（与IOptions接口一起使用的配置）是隔离开来的。</p></blockquote><p>配置你的app设置的方法 <code>ConfigureAppConfiguration()</code> 与2.X相比是没有变化的，所以它仍然使用appsettings.json文件、appsetting.ENV.json风格文件、<a href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets" target="_blank" rel="noopener">用户机密数据</a>、环境变量以及命令行参数。</p><p>通用Host的日志部分已经在3.0进行了扩展。它仍旧通过你的app配置来<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2#log-filtering" target="_blank" rel="noopener">配置日志等级过滤器</a>,以及添加控制台和Debug日志提供者。然而它同样也添加来<a href="https://andrewlock.net/logging-using-diagnosticsource-in-asp-net-core/" target="_blank" rel="noopener">事件源</a>日志提供者，事件源日志用于和像windows上的<a href="https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing" target="_blank" rel="noopener">ETW</a>、Linux上的<a href="https://lttng.org/" target="_blank" rel="noopener">LTTng</a>这样的系统日志进行交互。另外，添加一个<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2#windows-eventlog-provider" target="_blank" rel="noopener">Event Log provider</a>，只能在windows才会把日志信息写入Windows Event Log。</p><p>最后，当你的app运行在开发环境时，通用Host配置依赖注入容器的目的是它会验证范围（Scopes），这个操作和2.X一样。这旨在抓取捕获的依赖关系的实例，在这些实例中，你将一个范围（Scopes）的服务注入到单例服务中。在3.0中，通用Host通用能启动 <code>ValidateOnBuild</code> 的功能，我将会在下一篇博客中讲到。</p><p>通用Host一个关键的点是他是通用的，它和Asp Net core 或者Http 工作负载没有任何关联。你可以像经典的Asp Net core 应用一样把通用Host作为你的控制台app或者其他长运行服务的基石。在3.0中你只需要在你的Asp net core 层的顶部增加一个 <code>ConfigureWebHostDefaults()</code> 就可以搞定。</p><hr><h2 id="用ConfigureWebHostDefaults恢复Asp-Net-core功能"><a href="#用ConfigureWebHostDefaults恢复Asp-Net-core功能" class="headerlink" title="用ConfigureWebHostDefaults恢复Asp Net core功能"></a>用ConfigureWebHostDefaults恢复Asp Net core功能</h2><p>这篇博客已经很长了，所以在这里我不想深入挖掘太多的细节，但是，对于添加Asp Net core “层”到 通用Host上面而言，ConfigureWebHostDefaults扩展方法是非常有用的。就简单层面而言，调用这个方法会使Kestrel web 服务添加到这个host上面，但是这里面也存在了大量的<a href="https://github.com/aspnet/AspNetCore/blob/5b2f3fb5f7f24ac3e91c5150a55cc411b2b36b76/src/DefaultBuilder/src/WebHost.cs#L208">其他的改变</a>。下面是关于这个方法提供<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0#default-builder-settings" target="_blank" rel="noopener">内容概览</a>,(包含了<a href="https://github.com/aspnet/AspNetCore/blob/f990751f54/src/Hosting/Hosting/src/GenericHost/GenericWebHostBuilder.cs">GenericWebHostBuilder</a>提供的特性)</p><ul><li>为Host 配置添加了 <code>ASPNETCORE_</code> 前缀的环境变量（除了 <code>DOTNET_</code> 前缀的变量和命令行参数）</li><li><a href="https://github.com/aspnet/AspNetCore/blob/f990751f54/src/Hosting/Hosting/src/GenericHost/GenericWebHostedService.cs">增加</a>了 <code>GenericWebHostService</code> ，这是一个IHostedService的实现，它通常运行在Asp Net core服务上，这是一个主要的特性，这个特性为Asp Net core 复用通用Host提供了可能。</li><li>增加了一个额外的app配置源，在RazorUI类库中，这个 <code>StaticWebAssetsLoader</code> 与静态文件（css/js）共同发挥作用。</li><li>使用默认Kestrel配置（与2.X一样）</li><li>增加 <code>HostFilteringStartupFilter</code> (和2.0一样)</li><li>增加 <code>ForwardedHeadersStartupFilter</code> ,如果 <code>ForwardedHeaders_Enabled</code> 配置值是true，例如，如果<code>ASPNETCORE_FORWARDEDHEADERS_ENABLED</code> 环境变量的值是true。</li><li>启动windows上的IIS集成</li><li>增加一个<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#differences-from-earlier-versions-of-routing" target="_blank" rel="noopener">端点路由</a>到DI容器中</li></ul><p>大部分东西是和Asp net core2.x相同的，不同的地方是：app作为一个IHostService运行的基础设施、端点路由和<code>ForwardedHeadersStartupFilter</code> ,其中端点路由在3.0是全局启用的（不再像2.X局限于MVC/Razor页面了）</p><p><code>ForwardedHeadersStartupFilter</code> 在1.0已经出现了，当你的app运行在代理后面会用到它，是为了确保你的应用能处理SSL-负载和生成正确的URL。这么设计的目的是你能仅仅通过设置一个环境变量去配置一个使用 <code>X-Forwarded-For</code> 和 <code>X-Forwarded-Proto</code> 请求头的中间件。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇博客中我深挖了从Asp Net Core2.X到3.0中的仅仅两个文件——.csproj文件和Program.cs文件的变化。从表面上看，者仅仅是一些细微的变化，所有从2.X移植到3.0应该不会太难。这是天真地掩盖了其中的巨大的变化——共享框架的明显的变化，以及Asp Net core 已经在通用Host上重建了。</p><p>我认为大家遇到的最大的问题是Nuget 程序包的差异——一些app将要必须移除Asp Net Core 程序包的引用，同时要明确地引用其他的程序包。尽管解决这个问题是不太难，但是它会对不熟悉这个变化的用户带来困惑，所以应该第一时间审查这些变化</p>]]></content>
      
      <categories>
          
          <category> Asp.net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.net Core </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centos7离线安装rabbitmq</title>
      <link href="/2019/05/28/rabbitmqInstall/"/>
      <url>/2019/05/28/rabbitmqInstall/</url>
      <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>一台centos7的机器</li><li><a href="https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.8.2/erlang-21.3.8.2-1.el7.x86_64.rpm">erlang-21.3.8.2</a></li><li><a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.15/rabbitmq-server-3.7.15-1.el7.noarch.rpm">RabbitMQ 3.7.15</a></li><li><a href="https://centos.pkgs.org/7/centos-x86_64/socat-1.7.3.2-2.el7.x86_64.rpm.html" target="_blank" rel="noopener">socat-1.7.3.2-2.el7.x86_64.rpm</a></li></ul><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><ol><li>登录centos ，把上面的三个文件包复制到该系统下，打开命令行终端，切换到root账户</li><li>安装erlang：yum install ./erlang-21.3.8.2-1.el7.x86_64.rpm</li><li>查看erlang是否安装正确：执行 erl 命令查看安装的版本，输出示例如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Erlang/OTP 21 [erts-10.3.5.1] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1] [hipe]</span><br><span class="line"></span><br><span class="line">Eshell V10.3.5.1  (abort with ^G)</span><br></pre></td></tr></table></figure><ol start="4"><li>安装rabbitmq：执行命令：yum install ./rabbitmq-server-3.7.15-1.el7.noarch.rpm</li><li>执行命令： yum install ./rabbitmq-server-3.7.15-1.el7.noarch.rpm  激活rabbitmq daemon 进程</li><li>启动rabbitmq，执行命令：/sbin/service rabbitmq-server start</li></ol><h2 id="安装-rabbitmq常见故障"><a href="#安装-rabbitmq常见故障" class="headerlink" title="安装 rabbitmq常见故障"></a>安装 rabbitmq常见故障</h2><ul><li><p>问题：出现类似：socat-1.7.3.2-2.el7.x86_64: [Errno 256] No more mirrors to try 的错误<br>原因：系统没有安装 socat<br>解决方案：下载<a href="https://centos.pkgs.org/7/centos-x86_64/socat-1.7.3.2-2.el7.x86_64.rpm.html" target="_blank" rel="noopener">socat-1.7.3.2-2.el7.x86_64.rpm</a>，执行命令：yum install ./socat-1.7.3.2-2.el7.x86_64.rpm，</p></li><li><p>问题：出现类似：Error unpacking rpm package rabbitmq-server-3.7.15-1.el7.noarch<br>error: unpacking of archive failed on file 的错误<br>原因：复制rabbitmq rpm包到centos 系统出现错误，<br>解决方案：更换其他复制的方式</p></li></ul><h2 id="简单配置rabbitmq"><a href="#简单配置rabbitmq" class="headerlink" title="简单配置rabbitmq"></a>简单配置rabbitmq</h2><ul><li>启用webUI插件：执行命令 rabbitmq-plugins enable rabbitmq_management<br>可以在本机浏览器输入 <a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a> 访问rabbitmq主页，账户 guest 密码 guest</li><li>添加自定义用户名为 “admin” 以及密码为 “123456” 的管理员账号： 执行命令 rabbitmqctl add_user admin 123456</li><li>给admin账号设置为管理员：执行命令 rabbitmqctl set_user_tags admin administrator</li><li>给admin账号授权：执行命令 rabbitmqctl set_permissions -p / admin  “.<em>“ “.</em>“ “.*”</li><li>查看admin账户的权限： 执行命令 rabbitmqctl list_user_permissions admin</li></ul><h2 id="日志文件以及配置文件的位置"><a href="#日志文件以及配置文件的位置" class="headerlink" title="日志文件以及配置文件的位置"></a>日志文件以及配置文件的位置</h2><ul><li>日志文件在：$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log下面，一般 $RABBITMQ_LOG_BASE=$RABBITMQ_HOME/var/log/rabbitmq。一般默认日志文件会在/var/log/rabbitmq文件下<br>该日志文件的开始部分记录了rabbitmq 启动时查找相关文件的记录，例如：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node           : rabbit@macvm</span><br><span class="line">home dir       : /var/lib/rabbitmq</span><br><span class="line">config file(s) : (none)</span><br><span class="line">cookie hash    : jzIB5AXnFFYHzF/o4qC9sw==</span><br><span class="line">log(s)         : /var/log/rabbitmq/rabbit@macvm.log</span><br><span class="line">           : /var/log/rabbitmq/rabbit@macvm_upgrade.log</span><br><span class="line">database dir   : /var/lib/rabbitmq/mnesia/rabbit@macvm</span><br></pre></td></tr></table></figure><p>日志记录显示了各个系统文件对应的位置</p>]]></content>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net core 的Generic Host 之Generic Host Builder</title>
      <link href="/2019/05/18/generichost/"/>
      <url>/2019/05/18/generichost/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通用Host(Generic Host) 与 web Host 不同的地方就是通用Host解耦了Http请求管道，使得通用Host拥有更广的应用场景。比如：消息收发、后台任务以及其他非http的工作负载。这些场景都可以通过使用通用Host拥有横切（Cross-cutting）的能力，比如：配置、依赖注入和日志记录。</p><hr><h1 id="Generic-Host-Builder"><a href="#Generic-Host-Builder" class="headerlink" title="Generic Host Builder"></a>Generic Host Builder</h1><p>Asp net core 2.1版本推出了Generic Host Builder，但它仅仅用在了非http工作负载的场景，Generic Host Builder会在2019年发布的3.0版本中替换掉Web Host Builder。</p><p><img src="a.png" alt="avatar"></p><h1 id="2-x中的Generic-Host-Builder"><a href="#2-x中的Generic-Host-Builder" class="headerlink" title="2.x中的Generic Host Builder"></a>2.x中的Generic Host Builder</h1><p>asp net core 2.1没有使用Generic Host Builder，那么它的使用场景是什么呢？Generic Host Builder的在非http负载的使用场景有消息收发、后台任务等。<br>HostBuilder位于 Microsoft.Extensions.Hosting 命名空间下，实现了IHostBUilder接口。Net core 应用在Main()中最简单的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static async Task Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">   var host = new HostBuilder()</span><br><span class="line">      .Build(); </span><br><span class="line"></span><br><span class="line">   await host.RunAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Build()方法是初始化host实例，它仅仅能被调用一次，在Build()方法执行前调用ConfigureServices()方法可以用来配置host。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var host = new HostBuilder()</span><br><span class="line">   .ConfigureServices((hostContext, services) =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">      services.Configure&lt;HostOptions&gt;(option =&gt;</span><br><span class="line">      &#123;</span><br><span class="line">         // option.SomeProperty = ...</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;)</span><br><span class="line">   .Build();</span><br></pre></td></tr></table></figure><p>ConfigureServices((hostContext, services) 方法有一个HostBuilderContext参数和一个依赖注入的IServiceCollection参数。你也可以通过调用Configure()设置Host的其他设置，当前HostOptions对象只有一个Shutdown Timeout 属性。<br>你可以在<a href="https://github.com/aspnet/Docs/blob/master/aspnetcore/fundamentals/host/generic-host/samples/2.x/GenericHostSample/Program.cs">官方示例</a>看到更多的配置，下面是一个其中的代码片段：</p><p>Host 配置部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureHostConfiguration(configHost =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   configHost.SetBasePath(Directory.GetCurrentDirectory());</span><br><span class="line">   configHost.AddJsonFile(&quot;hostsettings.json&quot;, optional: true);</span><br><span class="line">   configHost.AddEnvironmentVariables(prefix: &quot;PREFIX_&quot;);</span><br><span class="line">   configHost.AddCommandLine(args);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>应用配置部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureAppConfiguration((hostContext, configApp) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   configApp.AddJsonFile(&quot;appsettings.json&quot;, optional: true);</span><br><span class="line">   configApp.AddJsonFile(</span><br><span class="line">      $&quot;appsettings.&#123;hostContext.HostingEnvironment.EnvironmentName&#125;.json&quot;, </span><br><span class="line">      optional: true);</span><br><span class="line">   configApp.AddEnvironmentVariables(prefix: &quot;PREFIX_&quot;);</span><br><span class="line">   configApp.AddCommandLine(args);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>依赖注入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureServices((hostContext, services) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   services.AddHostedService&lt;LifetimeEventsHostedService&gt;();</span><br><span class="line">   services.AddHostedService&lt;TimedHostedService&gt;();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>日志配置代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureLogging((hostContext, configLogging) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   configLogging.AddConsole();</span><br><span class="line">   configLogging.AddDebug();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-0web应用中的Generic-Host-Builder"><a href="#3-0web应用中的Generic-Host-Builder" class="headerlink" title="3.0web应用中的Generic Host Builder"></a>3.0web应用中的Generic Host Builder</h1><p>Asp net core 3.0 中使用Generic Host Builder 替换 Web Host Builder，net core 3.0 web 应用在Main函数中简单的使用方式代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">   CreateHostBuilder(args)</span><br><span class="line">      .Build()</span><br><span class="line">      .Run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;</span><br><span class="line">   Host.CreateDefaultBuilder(args)</span><br><span class="line">      ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">      &#123;</span><br><span class="line">         webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>3.0版本中的CreateHostBuilder方法与2.x版本的 CreateWebHostBuilder() 方法很相似，二者最大的不同就是WebHost.CreateDefaultBuilder() 被替换成 Host.CreateDefaultBuilder()，<br>还有一个不同的地方就是 Host.CreateDefaultBuilder()方法，因为新版本的host builder是一个通用的host builder，这样就要通过嗲用  CreateDefaultBuilder()方法来构建一个web app host。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>未来我们需要知道：</p><ul><li>WebHostBuilder在未来将会被弃用</li><li>IWebHostBuilder接口将会被保留</li><li>你不能在Startup类里面注入任何服务，IHostingEnvironment and IConfiguration除外</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0" target="_blank" rel="noopener">官方文档</a><br><a href="https://wakeupandcode.com/generic-host-builder-in-asp-net-core/" target="_blank" rel="noopener">Generic Host Builder in ASP .NET Core</a></p>]]></content>
      
      
        <tags>
            
            <tag> Net Core Generic Host </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义Asp.net core——日志记录</title>
      <link href="/2019/04/06/Asp-Net-core-log/"/>
      <url>/2019/04/06/Asp-Net-core-log/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文我将演示如何定制日志记录。默认的日志记录仅仅向控制台或者debug窗口输出日志，这样可以满足一些情况，但是你可能还需要把日志记录到一个磁盘文件或者数据库，或者你想为记录额外的信息。这样的场景你就需要知道如何修改默认的日志记录。</p><hr><h1 id="配置日志记录"><a href="#配置日志记录" class="headerlink" title="配置日志记录"></a>配置日志记录</h1><p>在asp.net core 2.0以前的版本，日志记录是在Startup.cs中，从2.0开始startup.cs被简化，并且把大量的配置代码转移到了webhostBuider中（3.0 是CreateDefaultBuilder）。同样日志记录配置也被转移到了该地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">    &#123;</span><br><span class="line">        public static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            CreateHostBuilder(args).Build().Run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在asp.net core 中你几乎可以修改所有的东西。所以你也能够定制日志记录。IHostBuilder有很多可以覆盖默认行为的扩展方法。我们需要用ConfigureLogging方法去覆盖日志记录的默认逻辑。下面在CreateDefaultBuilder插入的代码演示了如何配置日志记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureLogging((hostingContext, logging) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;));</span><br><span class="line">                        logging.AddConsole();</span><br><span class="line">                        logging.AddDebug();</span><br><span class="line">                    &#125;)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt; &#123; webBuilder.UseStartup&lt;Startup&gt;(); &#125;);</span><br></pre></td></tr></table></figure><p>这个方法需要一个获取HostBuilderContext的lambda表达式，HostBuilderContext包含了用于配置日志的hosting context和一个LoggingBuilder。</p><h1 id="创建一个自定义的logger"><a href="#创建一个自定义的logger" class="headerlink" title="创建一个自定义的logger"></a>创建一个自定义的logger</h1><p>为了演示如何自定义logger，我创建一个简单的logger，这个logger能够把指定的日志等级用带颜色的文字输出到控制台。我们创建一个名为ColoredConsoleLogger的类，我们同样写一个LoggerProvider用来增加与创建上面的logger。为了把输出指定的颜色和日志等级，我们还需要增加一个配置类，下面代码包含了上述三部分的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class ColoredConsoleLoggerConfiguration</span><br><span class="line">    &#123;</span><br><span class="line">        public LogLevel LogLevel &#123; get; set; &#125; = LogLevel.Warning;</span><br><span class="line">        public int EventId &#123; get; set; &#125; = 0;</span><br><span class="line">        public ConsoleColor Color &#123; get; set; &#125; = ConsoleColor.Yellow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class ColoredConsoleLoggerProvider : ILoggerProvider</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly ColoredConsoleLoggerConfiguration _config;</span><br><span class="line"></span><br><span class="line">        private readonly ConcurrentDictionary&lt;string, ColoredConsoleLogger&gt; _loggers =</span><br><span class="line">            new ConcurrentDictionary&lt;string, ColoredConsoleLogger&gt;();</span><br><span class="line"></span><br><span class="line">        public ColoredConsoleLoggerProvider(ColoredConsoleLoggerConfiguration config)</span><br><span class="line">        &#123;</span><br><span class="line">            _config = config;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ILogger CreateLogger(string categoryName)</span><br><span class="line">        &#123;</span><br><span class="line">            return _loggers.GetOrAdd(categoryName, name =&gt; new ColoredConsoleLogger(name, _config));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Dispose()</span><br><span class="line">        &#123;</span><br><span class="line">            _loggers.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class ColoredConsoleLogger : ILogger</span><br><span class="line">    &#123;</span><br><span class="line">        private static object _lock = new Object();</span><br><span class="line">        private readonly string _name;</span><br><span class="line">        private readonly ColoredConsoleLoggerConfiguration _config;</span><br><span class="line"></span><br><span class="line">        public ColoredConsoleLogger(string name, ColoredConsoleLoggerConfiguration config)</span><br><span class="line">        &#123;</span><br><span class="line">            _name = name;</span><br><span class="line">            _config = config;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IDisposable BeginScope&lt;TState&gt;(TState state)</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public bool IsEnabled(LogLevel logLevel)</span><br><span class="line">        &#123;</span><br><span class="line">            return logLevel == _config.LogLevel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception,</span><br><span class="line">            Func&lt;TState, Exception, string&gt; formatter)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!IsEnabled(logLevel))</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lock (_lock)</span><br><span class="line">            &#123;</span><br><span class="line">                if (_config.EventId == 0 || _config.EventId == eventId.Id)</span><br><span class="line">                &#123;</span><br><span class="line">                    var color = Console.ForegroundColor;</span><br><span class="line">                    Console.ForegroundColor = _config.Color;</span><br><span class="line">                    Console.WriteLine(</span><br><span class="line">                        $&quot;&#123;logLevel.ToString()&#125; - &#123;eventId.Id&#125; - &#123;_name&#125; - &#123;formatter(state, exception)&#125;&quot;);</span><br><span class="line">                    Console.ForegroundColor = color;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们需要对具体的控制台输出加上锁，因为控制台不是线程安全的。接下来我们就可以把自定义的logger添加到ConfigureLogging方法中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">logging.ClearProviders();</span><br><span class="line"></span><br><span class="line">var config = new ColoredConsoleLoggerConfiguration</span><br><span class="line">&#123;</span><br><span class="line">    LogLevel = LogLevel.Information,</span><br><span class="line">    Color = ConsoleColor.Red</span><br><span class="line">&#125;;</span><br><span class="line">logging.AddProvider(new ColoredConsoleLoggerProvider(config));</span><br></pre></td></tr></table></figure><p>我们可以清除之前已经添加的logger provider，然后我们通过AddProvider增加一个指定对应的日志记录设置ColoredConsoleLoggerProvider实例。我们也可以增加其他不同日志记录设置的实例。下图我们就可以看到我们自定义日志记录的效果输出</p><p><img src="1.png" alt="avatar"></p>]]></content>
      
      <categories>
          
          <category> Asp.net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core Log </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>.Net Core与跨平台时区</title>
      <link href="/2018/11/18/cross-platformTimeZones/"/>
      <url>/2018/11/18/cross-platformTimeZones/</url>
      <content type="html"><![CDATA[<p>由于开发者不熟悉不同操作系统管理时区的方式，当用.Net Core开发与时区相关的应用运行在不同操作系统上会出现错误。这片文章将会探索一下在不同操作系统上用.Net Core 使用时区信息出现的问题与解决方案</p><h1 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h1><p>假设你用.Net Core 开发一个获取特定时区信息的控制台程序，你可能会这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    TimeZoneInfo tzi = TimeZoneInfo.FindSystemTimeZoneById(&quot;Central Standard Time&quot;);</span><br><span class="line">    Console.WriteLine(tzi.DisplayName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序在我win10系统上运行，我看到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(UTC-06:00) Central Time (US &amp; Canada)</span><br></pre></td></tr></table></figure><p>如果我把该程序在我的ubuntu上运行，我看到抛出了下面的异常信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xception has occurred: CLR/System.TimeZoneNotFoundException</span><br><span class="line">An unhandled exception of type &apos;System.TimeZoneNotFoundException&apos; occurred in System.Private.CoreLib.dll: &apos;The time zone ID &apos;Central Standard Time&apos; was not found on the local computer.&apos;</span><br></pre></td></tr></table></figure><p>这其中发生了什么？让我们花一点时间深入研究和探索这其中到底真正是什么原因造成的。</p><h1 id="时区的不同"><a href="#时区的不同" class="headerlink" title="时区的不同"></a>时区的不同</h1><p>windows系统通过windows注册表来维护一个时区列表。在<a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones" target="_blank" rel="noopener">这里</a>你能发现这些列表的值。</p><p>相反，linux系统通过 Internet Assigned Numbers Authority (IANA)维护的时区数据库。你能在<a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA</a>的网站找到最新的数据。这里是一个IANA 时区的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">America/New_York</span><br></pre></td></tr></table></figure><p>当你使用上面两种格式的其中一种开发.Net Core 代码，然后运行你的程序在另外一种操作系统时候，这个问题就会出现。如果你出现了这样的问题，你需要处理不同操作系统下的时区管理方式，因为.Net Core 运行时只会遵循当前正在运行测操作系统的时区管理机制。</p><h1 id="我们该如何解决这个问题？"><a href="#我们该如何解决这个问题？" class="headerlink" title="我们该如何解决这个问题？"></a>我们该如何解决这个问题？</h1><p>在github上有一个能解决这个问题的开源项目。你可以参考这个项目的<a href="https://github.com/mj1856">作者</a>贡献的<a href="https://github.com/mj1856/TimeZoneConverter">源代码</a>。你也可以用下面的命令行的方式在nuget上获取这个包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package TimeZoneConverter</span><br></pre></td></tr></table></figure><p>完成安装后，你就可以在不同操作系统上使用统一的方式区解决时区的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TimeZoneInfo tzi = TZConvert.GetTimeZoneInfo(&quot;Central Standard Time&quot;);</span><br><span class="line">TimeZoneInfo tzi = TZConvert.GetTimeZoneInfo(&quot;America/New_York&quot;);</span><br></pre></td></tr></table></figure><p>因为时区数据是经常更新的，所以你需要留意这个项目的文档，确保你的安装包是最新的。</p>]]></content>
      
      <categories>
          
          <category> .Net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .Net core TIme Zones </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>横向扩展你的ASP.NET Core SignalR 应用（翻译）</title>
      <link href="/2018/08/18/Asp-netCoreSignalR/"/>
      <url>/2018/08/18/Asp-netCoreSignalR/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目要用signalr来做实时通信，在研究asp.netcore signalr 应用横向扩展时候发现了这篇国外的博客，和大家分享一下<br><a href="https://rolandguijt.com/scaling-out-your-asp-net-core-signalr-application" target="_blank" rel="noopener">原文连接地址</a></p><hr><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>当你把你的应用部署到生产环境时，你将会想横向扩展你的应用。横向扩展意味着要你的应用要在多台服务器上运行。<br>当应用运行在云端进行横向扩展时，你要考虑的主要问题时设置你想运行服务器的数量。有一种叫做负载均衡的机制，<br>这种机制会对每个传入的请求选择一个服务器。负载均衡能按照顺序选择不同的服务器或者根据其他的处理逻辑继续选择同一个。</p><hr><h1 id="Websockets"><a href="#Websockets" class="headerlink" title="Websockets"></a>Websockets</h1><p>当使用web sockets时没有什么问题（译注：意思指使用无状态的负载均衡时候）。因为web sockets一旦建立了就像服务端和浏览器建立了一个管道。但是当使用轮询或者长轮询时候就可能出现，每个消息时不同的请求并且每个处理的请求都能转换到不同的服务器。服务器坑不知道之前发送到这个客户端的消息和关于这个消息的上下文。<br>举例你的应用被横向扩展到不同服务器上，服务器1正在获取关于准备订单1（prepare order 1）的请求然后它开始处理这个请求。当你使用长轮询方式进行请求时候，接下来的请求会通过负载均衡分配到不同的服务器。这个服务器是不知道关于 订单1（order1）的信息的。<br>对于服务端发送事件（译注：<a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">关于服务器发送事</a>)也会出现同样的问题，因为http连接可能会被删除，这个连接将立刻会通过在浏览器的事件源（EventSource）恢复。</p><hr><h1 id="粘连会话（Sticky-Sessions）"><a href="#粘连会话（Sticky-Sessions）" class="headerlink" title="粘连会话（Sticky Sessions）"></a>粘连会话（Sticky Sessions）</h1><p>我们能通过使用粘连会话解决这个问题。粘连会话有很多种实现，大部分实现方式如下，对于第一次请求的响应负载均衡能在浏览器设置一个cookie用来指明这个使用的服务器。在接下来的请求负载均衡能读取这个cookie并且分配这个请求到同一台服务器。</p><p><img src="1.png" alt="avatar"></p><p>IIS和Azure web应用的粘连会话的版本称作应用请求路由关联（Application Request Routing Affinity ）或者 ARR Affinity。自从SignalR能使用 非web sockets 传输协议，当你使用已经安装好ARR Affinity 模块的IIS内网服务器时，你就应该在你应用运行的所有的服务器端开启它。同时也要确保web sockets也同样是要开启的。否则你的服务器将会使用服务器发送事件。</p><p><img src="2.png" alt="avatar"></p><hr><h1 id="在不同应用实例之间同步客户端"><a href="#在不同应用实例之间同步客户端" class="headerlink" title="在不同应用实例之间同步客户端"></a>在不同应用实例之间同步客户端</h1><p>但是这里会存在另外一个问题。举例说一个使用Office 365的用户通过web document 工作，然后她邀请了其他人加入。其他人可能在与先前用户不同的服务器上。现在当使用服务器1的用户（译注：指第一个用户）不得不发送 改变文档的消息到其他人。但是服务器1不知道在其他服务器上连接这个 管道（Hub）上的其他用户的信息。为了解决这个问题服务器需要一种方式进行数据共享。这样方式能通过数据库来实现，但是用一个存储更快的可替代的方案就是使用redis缓存。SignalR支持开箱即用的redis，我们接下来就会看到。它实际上就是使用了Redis内置的发布订阅功能来同步不同服务器上的客户端信息。<br>解决这个问题是非常简单甚至不需要一个截图。安装一个Microsoft.AspNetCore.SignalR.Redis nuget包。然后在startup类中的 configure services方法中的AddSignalR后面输入 AddRedis 并且传入一个redis连接字符串。你能自己搭建Redis服务器或者使用 Azure Redis service。除了Redis你同样也可以使用社区构建的其他数据存储。但是Redis的优势就是它甚至不需要持久化这个数据。</p><hr><h1 id="Azure-SignalR-Service"><a href="#Azure-SignalR-Service" class="headerlink" title="Azure SignalR Service"></a>Azure SignalR Service</h1><p>除了粘连会话、Redis 缓存我们还没有讨论连接限制。每个客户端同时有六个连接的Http连接限制。当使用长轮询或者服务器发送事件这个限制很快就会达到了。即使web sockets也有大约50个连接限制。如果你不喜欢管理这些东西，这里有一个一站式解决方案：Azure SignalR Service。它的工作原理如下：<br><img src="3.png" alt="avatar"></p><p>所有的客户端连接都被托管在Azure SignalR Service上，所以客户端并不是真正连接到你应用运行的服务器上。当一个新的客户端连接或者你发送一个消息到所有的客户端或者分组或者独立的客户端时候，你的应用实际上经过了一个管道连接，这个管道连接负责与SignalR Service（译注：指Azure SignalR Service）通信。只要你为需要同时支持的连接付费，那么你所有包含hub的应用代码只需要运行在服务器上，你关心的 粘连会话、Redis缓存以及连接限制都将不是事儿。<br>结合Azure SignalR Service 和增加Redis缓存一样简单。(译注：这里有一个github上关于signalr 客户端同步的issue，供大家参考一下，<a href="https://github.com/aspnet/SignalR/issues/2002">链接地址</a>)</p><hr>]]></content>
      
      <categories>
          
          <category> Asp.net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASP.NET Core SignalR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解Aspnet Core之Identity(5)</title>
      <link href="/2018/04/22/Identity5/"/>
      <url>/2018/04/22/Identity5/</url>
      <content type="html"><![CDATA[<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>本篇我将会介绍验证用户的机制当账户被创建的时候，同样 这个过程主要有IUserValidator这个接口来实现的，和密码验证一样Identity同样也内置已经实现好的账户验证。账户验证的比较简单，我会先介绍内置的IUserValidator的使用，然后会简单介绍一些源代码，最后会演示怎实现一个自定义的IUserValidator。</p><hr><h3 id="使用内置的IUserValidator来定义用户户名的规则"><a href="#使用内置的IUserValidator来定义用户户名的规则" class="headerlink" title="使用内置的IUserValidator来定义用户户名的规则"></a>使用内置的IUserValidator来定义用户户名的规则</h3><p>用户名验证规则是在Startup类 里面进行配置的，通过用IdentityOptions.User进行配置，IdentityOptions.User是UserOptions类的实例。UserOptions属性的列表如下：</p><ul><li>AllowedUserNameCharacters ：类型string 代表用户创建用户名可以使用的字符，默认为：abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+</li><li>RequireUniqueEmail ：类型 bool，true 代表创建账户使用的email必须是没有被用过的。</li></ul><p>现在Startup类中的ConfigureServices方法配置用户名验证规则，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            //注入自定义密码验证类</span><br><span class="line">            services.AddTransient&lt;IPasswordValidator&lt;AppUser&gt;,</span><br><span class="line">                CustomPasswordValidator&gt;();</span><br><span class="line">            </span><br><span class="line">            services.AddDbContext&lt;AppIdentityDbContext&gt;(options =&gt;</span><br><span class="line">                options.UseSqlServer(</span><br><span class="line">                    Configuration[&quot;Data:AppStoreIdentity:ConnectionString&quot;]));</span><br><span class="line">            //配置</span><br><span class="line">            services.AddIdentity&lt;AppUser, IdentityRole&gt;(opts =&gt; &#123;</span><br><span class="line">                    //配置用户名验证规则</span><br><span class="line">                    opts.User.RequireUniqueEmail = true;</span><br><span class="line">                    opts.User.AllowedUserNameCharacters = &quot;testabc&quot;;</span><br><span class="line">                    //配置密码强度</span><br><span class="line">                    opts.Password.RequiredLength = 6;</span><br><span class="line">                    opts.Password.RequireNonAlphanumeric = false;</span><br><span class="line">                    opts.Password.RequireLowercase = false;</span><br><span class="line">                    opts.Password.RequireUppercase = false;</span><br><span class="line">                    opts.Password.RequireDigit = false;</span><br><span class="line">                &#125;).AddEntityFrameworkStores&lt;AppIdentityDbContext&gt;()</span><br><span class="line">                .AddDefaultTokenProviders();</span><br><span class="line">            services.AddMvc();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><ul><li>当用户创建账户时候要求email必须是未使用过的，用户名仅包含 testabc 这里面的字符。<br>我们启动网站，创建一个账户，看一下配置是否生效，结果如下图：<br><img src="1.png" alt="avatar"></li></ul><hr><h3 id="自定义用户验证"><a href="#自定义用户验证" class="headerlink" title="自定义用户验证"></a>自定义用户验证</h3><ul><li><p>虽然内置的用户验证可以满足很多场景，但是假如我们要求创建的拥护都要包含<a href="mailto:test@163.com" target="_blank" rel="noopener">test@163.com</a>这个后缀时，我们就需要自定义一个用户验证类了。</p><h2 id="IUserValidator接口的源代码"><a href="#IUserValidator接口的源代码" class="headerlink" title="IUserValidator接口的源代码"></a>IUserValidator接口的源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Copyright (c) .NET Foundation. All rights reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.</span><br><span class="line"></span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace Microsoft.AspNetCore.Identity</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Provides an abstraction for user validation.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type encapsulating a user.&lt;/typeparam&gt;</span><br><span class="line">    public interface IUserValidator&lt;TUser&gt; where TUser : class</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Validates the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;manager&quot;&gt;The &lt;see cref=&quot;UserManager&#123;TUser&#125;&quot;/&gt; that can be used to retrieve user properties.&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;user&quot;&gt;The user to validate.&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the validation operation.&lt;/returns&gt;</span><br><span class="line">        Task&lt;IdentityResult&gt; ValidateAsync(UserManager&lt;TUser&gt; manager, TUser user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该接口很简单就包含了 ValidateAsync方法，用于验证用户名，</p><h2 id="实现IUserValidator-接口"><a href="#实现IUserValidator-接口" class="headerlink" title="实现IUserValidator 接口"></a>实现IUserValidator 接口</h2><p>在Infrastructure文件夹中创建一个CustomUserValidator C#文件，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> using System.Threading.Tasks;</span><br><span class="line">using DemoUser.Models;</span><br><span class="line">using Microsoft.AspNetCore.Identity;</span><br><span class="line"></span><br><span class="line">namespace DemoUser.Infrastructure</span><br><span class="line">&#123;</span><br><span class="line">    public class CustomUserValidator</span><br><span class="line">    &#123;</span><br><span class="line">        public Task&lt;IdentityResult&gt; ValidateAsync(UserManager&lt;AppUser&gt; manager,</span><br><span class="line">            AppUser user) &#123;</span><br><span class="line">            if (user.Email.ToLower().EndsWith(&quot;test@163.com&quot;)) &#123;</span><br><span class="line">                return Task.FromResult(IdentityResult.Success);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Task.FromResult(IdentityResult.Failed(new IdentityError &#123;</span><br><span class="line">                    Code = &quot;EmailError&quot;,</span><br><span class="line">                    Description = &quot;仅仅可以包含test@163.com后缀&quot;</span><br><span class="line">                &#125;));</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们在Startup类中的ConfigureServices 注入我们自定义的CustomUserValidator类，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">       &#123;</span><br><span class="line">           //注入自定义用户名验证类</span><br><span class="line">           services.AddTransient&lt;IUserValidator&lt;AppUser&gt;,</span><br><span class="line">               CustomUserValidator&gt;();</span><br><span class="line"></span><br><span class="line">           //注入自定义密码验证类</span><br><span class="line">           services.AddTransient&lt;IPasswordValidator&lt;AppUser&gt;,</span><br><span class="line">               CustomPasswordValidator&gt;();</span><br><span class="line">           </span><br><span class="line">           services.AddDbContext&lt;AppIdentityDbContext&gt;(options =&gt;</span><br><span class="line">               options.UseSqlServer(</span><br><span class="line">                   Configuration[&quot;Data:AppStoreIdentity:ConnectionString&quot;]));</span><br><span class="line">           //配置</span><br><span class="line">           services.AddIdentity&lt;AppUser, IdentityRole&gt;(opts =&gt; &#123;</span><br><span class="line">                   //配置用户名验证规则</span><br><span class="line">                   opts.User.RequireUniqueEmail = true;</span><br><span class="line">                   opts.User.AllowedUserNameCharacters = &quot;testabc&quot;;</span><br><span class="line">                   //配置密码强度</span><br><span class="line">                   opts.Password.RequiredLength = 6;</span><br><span class="line">                   opts.Password.RequireNonAlphanumeric = false;</span><br><span class="line">                   opts.Password.RequireLowercase = false;</span><br><span class="line">                   opts.Password.RequireUppercase = false;</span><br><span class="line">                   opts.Password.RequireDigit = false;</span><br><span class="line">               &#125;).AddEntityFrameworkStores&lt;AppIdentityDbContext&gt;()</span><br><span class="line">               .AddDefaultTokenProviders();</span><br><span class="line">           services.AddMvc();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样我们就成功替换掉内置的用户验证类了。重新运行程序就可以了。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这篇介绍了IUserValidator的使用方法，以及如何自定义我们自己的规则。从下一篇开始我打算开始介绍如何用Identity来对用户进行验证和授权。<br><a href="https://github.com/bluetianx/AspnetCoreExample">github地址</a> 对应分支f5</p></li></ul>]]></content>
      
      <categories>
          
          <category> Asp.net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.net core Identity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解Aspnet Core之Identity(4)</title>
      <link href="/2018/04/16/Identity4/"/>
      <url>/2018/04/16/Identity4/</url>
      <content type="html"><![CDATA[<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><pre><code>之前简单介绍了Asp.net core 的初步的使用，本篇我打算给大家介绍一下Identity的架构，让大家对Identity有一个总体的理解和认识。</code></pre><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Identity的基本的架构图如下：<br><img src="arc.png" alt="avatar"></p><ul><li>Asp.net core Identity 是由一系列名为managers 和 stores 类组成的。manager层是主要identity架构的最高层，开发者主要在应用开发中用来对Identity User 进行管理，比如CRUD等操作。Stores 层相对于manager层在架构图中属于较低层次的类，主要用于持久化 用户（user）、角色（role）等信息，同时store类遵循了 <a href="http://deviq.com/repository-pattern" target="_blank" rel="noopener">仓储模式</a>.manager层和store层 是完全解耦的。意味着你可以自己重写store的持久化机制并且还不用修改上层的代码。</li><li>假如你打算创建自己的 存储提供器（storage provider），那么你需要创建上面架构图中的绿色和灰色层的部分，你不需要重写蓝色层的部分。当你为你提供的user创建一个UserManager 或者 RoleManager示例的时，需要提供一个 store类作为参数，这样就为你加入自己定义的代码提供了机会。</li></ul><hr><h3 id="Asp-net-core-Identity-存储数据（stores-data）类型"><a href="#Asp-net-core-Identity-存储数据（stores-data）类型" class="headerlink" title="Asp.net core Identity 存储数据（stores data）类型"></a>Asp.net core Identity 存储数据（stores data）类型</h3><h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><p>代表了网站的注册用户，内置的Identity User 能被扩展根据自身的需要。不需要自己直接去实现。<br>示例代码如下：</p><pre><code class="C#">using Microsoft.AspNetCore.Identity;namespace DemoUser.Models{    public class AppUser:IdentityUser    {    }}</code></pre><h2 id="User-Claims"><a href="#User-Claims" class="headerlink" title="User Claims"></a>User Claims</h2><p>User Claims 是关于用户的声明的集合，它比起传统的通过角色的机制更加强大，可以描述更多的用户信息。</p><h2 id="User-Logins"><a href="#User-Logins" class="headerlink" title="User Logins"></a>User Logins</h2><p>是关于外部认证用户提供者（external authentication provider）（比如：谷歌、新浪等）的信息</p><h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><p>代表了网站的授权组，包含角色ID ROleID、角色名 RoleName </p><hr><h3 id="数据访问层"><a href="#数据访问层" class="headerlink" title="数据访问层"></a>数据访问层</h3><p>数据访问层用于保存网站的用户账户数据到数据源。我们可以自定义开发这一层，数据访问层包含了多个存储类型比如User Storage、Role Storage。你可以根据自己应用网站的设计需要来实现这些存储类，假如你的网站不需要角色类型，那么就不需要实现Role Storage。</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这篇简单介绍了一下Identity的架构设计。后续我打算自定义实现架构图中的绿色和灰色部分，到那时候我们在深入讨论一下如何实现。下一篇我将会分享关于 用户验证，包括当用户创建时候怎么验证用户名和email地址。</p>]]></content>
      
      <categories>
          
          <category> Asp.net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.net core Identity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解Aspnet Core之Identity(3)</title>
      <link href="/2018/04/07/Identity3/"/>
      <url>/2018/04/07/Identity3/</url>
      <content type="html"><![CDATA[<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p> 账户管理一个比较常见的功能就是密码强度策略，Identity已经内置了一个通用的可配置的策略，我们一般情况下可以直接拿来用即可。本篇我会介绍一些<br>Identity内置的密码策略类：PasswordValidator，并且简单介绍一下源码。最好我们还会自定义一个密码策略类的实现。</p><hr><h3 id="密码强度配置"><a href="#密码强度配置" class="headerlink" title="密码强度配置"></a>密码强度配置</h3><p>我们需要在startup类里面配置，密码强度策略。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddDbContext&lt;AppIdentityDbContext&gt;(options =&gt;</span><br><span class="line">                options.UseSqlServer(</span><br><span class="line">                    Configuration[&quot;Data:AppStoreIdentity:ConnectionString&quot;]));</span><br><span class="line">            //配置密码强度</span><br><span class="line">            services.AddIdentity&lt;AppUser, IdentityRole&gt;(opts =&gt; &#123;</span><br><span class="line">                    opts.Password.RequiredLength = 6;</span><br><span class="line">                    opts.Password.RequireNonAlphanumeric = false;</span><br><span class="line">                    opts.Password.RequireLowercase = false;</span><br><span class="line">                    opts.Password.RequireUppercase = false;</span><br><span class="line">                    opts.Password.RequireDigit = false;</span><br><span class="line">                &#125;).AddEntityFrameworkStores&lt;AppIdentityDbContext&gt;()</span><br><span class="line">                .AddDefaultTokenProviders();</span><br><span class="line">            services.AddMvc();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>这个 AddIdentity 方法接受一个 IdentityOptions 对象参数，这个对象包含了所有能用于配置Identity系统的配置项，其中就包含了密码强度的配置。PassWord属性包含了可用于密码强度的配置项，其中包括：</p><ul><li>RequiredLength ：这个属性用于指明密码的最小长度，类型 int</li><li>RequireNonAlphanumeric ：类型：bool，true代表密码至少包含一个非字母或者数字的字符，比如 ！@#</li><li>RequireLowercase ：类型bool，true代表密码至少包含一个小写字母</li><li>RequireUppercase ：类型 bool，true 代表密码至少包含一个大写字母</li><li>RequireDigit ：类型 bool，true 代表密码至少包含一个数字<br>这里我配置的密码强度是不少于六位的字符即可。<h3 id="IdentityOptions-类可用于配置的属性"><a href="#IdentityOptions-类可用于配置的属性" class="headerlink" title="IdentityOptions 类可用于配置的属性"></a>IdentityOptions 类可用于配置的属性</h3>在这里我们把IdentityOptions对应的源代码展现给大家，让大家了解一下哪些可用于配置Identity，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">    /// Represents all the options you can use to configure the identity system.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class IdentityOptions</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;ClaimsIdentityOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;ClaimsIdentityOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public ClaimsIdentityOptions ClaimsIdentity &#123; get; set; &#125; = new ClaimsIdentityOptions();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;UserOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;UserOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public UserOptions User &#123; get; set; &#125; = new UserOptions();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;PasswordOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;PasswordOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public PasswordOptions Password &#123; get; set; &#125; = new PasswordOptions();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;LockoutOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;LockoutOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public LockoutOptions Lockout &#123; get; set; &#125; = new LockoutOptions();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;SignInOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;SignInOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public SignInOptions SignIn &#123; get; set; &#125; = new SignInOptions();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;TokenOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;TokenOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public TokenOptions Tokens &#123; get; set; &#125; = new TokenOptions();</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets or sets the &lt;see cref=&quot;StoreOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;</span><br><span class="line">        /// The &lt;see cref=&quot;StoreOptions&quot;/&gt; for the identity system.</span><br><span class="line">        /// &lt;/value&gt;</span><br><span class="line">        public StoreOptions Stores &#123; get; set; &#125; = new StoreOptions();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们除了可以用 IdentityOptions 配置密码策略，还可以用于配置 持久化配置StoreOptions，令牌配置TokenOption等；</p><hr><h3 id="自定义实现IPasswordValidator"><a href="#自定义实现IPasswordValidator" class="headerlink" title="自定义实现IPasswordValidator"></a>自定义实现IPasswordValidator</h3><ul><li>我们首先看一下 IPasswordValidator 接口的定义；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Copyright (c) .NET Foundation. All rights reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.</span><br><span class="line"></span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace Microsoft.AspNetCore.Identity</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Provides an abstraction for validating passwords.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type that represents a user.&lt;/typeparam&gt;</span><br><span class="line">    public interface IPasswordValidator&lt;TUser&gt; where TUser : class</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Validates a password as an asynchronous operation.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;manager&quot;&gt;The &lt;see cref=&quot;UserManager&#123;TUser&#125;&quot;/&gt; to retrieve the &lt;paramref name=&quot;user&quot;/&gt; properties from.&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;user&quot;&gt;The user whose password should be validated.&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;password&quot;&gt;The password supplied for validation&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;The task object representing the asynchronous operation.&lt;/returns&gt;</span><br><span class="line">        Task&lt;IdentityResult&gt; ValidateAsync(UserManager&lt;TUser&gt; manager, TUser user, string password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口接受一个泛型T，这个T是应用指定的用户类User，这里我们是 AppUser类。这个接口包含类一个方法 ValidateAsync，这是一个异步方法，用于验证密码是否符合策略。这个方法返回 IdentityResult 类，假如验证没有问题，你可以用静态的IdentityResult.Success属性返回该对象，反之，用Failed静态属性返回。</p><ul><li>现在我们去了解一下IPasswordValidator接口的默认实现，先附上源代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">// Copyright (c) .NET Foundation. All rights reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.</span><br><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace Microsoft.AspNetCore.Identity</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Provides the default password policy for Identity.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type that represents a user.&lt;/typeparam&gt;</span><br><span class="line">    public class PasswordValidator&lt;TUser&gt; : IPasswordValidator&lt;TUser&gt; where TUser : class</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Constructions a new instance of &lt;see cref=&quot;PasswordValidator&#123;TUser&#125;&quot;/&gt;.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;errors&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; to retrieve error text from.&lt;/param&gt;</span><br><span class="line">        public PasswordValidator(IdentityErrorDescriber errors = null)</span><br><span class="line">        &#123;</span><br><span class="line">            Describer = errors ?? new IdentityErrorDescriber();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Gets the &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to supply error text.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;value&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to supply error text.&lt;/value&gt;</span><br><span class="line">        public IdentityErrorDescriber Describer &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Validates a password as an asynchronous operation.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;manager&quot;&gt;The &lt;see cref=&quot;UserManager&#123;TUser&#125;&quot;/&gt; to retrieve the &lt;paramref name=&quot;user&quot;/&gt; properties from.&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;user&quot;&gt;The user whose password should be validated.&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;password&quot;&gt;The password supplied for validation&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;The task object representing the asynchronous operation.&lt;/returns&gt;</span><br><span class="line">        public virtual Task&lt;IdentityResult&gt; ValidateAsync(UserManager&lt;TUser&gt; manager, TUser user, string password)</span><br><span class="line">        &#123;</span><br><span class="line">            if (password == null)</span><br><span class="line">            &#123;</span><br><span class="line">                throw new ArgumentNullException(nameof(password));</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager == null)</span><br><span class="line">            &#123;</span><br><span class="line">                throw new ArgumentNullException(nameof(manager));</span><br><span class="line">            &#125;</span><br><span class="line">            var errors = new List&lt;IdentityError&gt;();</span><br><span class="line">            var options = manager.Options.Password;</span><br><span class="line">            if (string.IsNullOrWhiteSpace(password) || password.Length &lt; options.RequiredLength)</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(Describer.PasswordTooShort(options.RequiredLength));</span><br><span class="line">            &#125;</span><br><span class="line">            if (options.RequireNonAlphanumeric &amp;&amp; password.All(IsLetterOrDigit))</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(Describer.PasswordRequiresNonAlphanumeric());</span><br><span class="line">            &#125;</span><br><span class="line">            if (options.RequireDigit &amp;&amp; !password.Any(IsDigit))</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(Describer.PasswordRequiresDigit());</span><br><span class="line">            &#125;</span><br><span class="line">            if (options.RequireLowercase &amp;&amp; !password.Any(IsLower))</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(Describer.PasswordRequiresLower());</span><br><span class="line">            &#125;</span><br><span class="line">            if (options.RequireUppercase &amp;&amp; !password.Any(IsUpper))</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(Describer.PasswordRequiresUpper());</span><br><span class="line">            &#125;</span><br><span class="line">            if (options.RequiredUniqueChars &gt;= 1 &amp;&amp; password.Distinct().Count() &lt; options.RequiredUniqueChars)</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(Describer.PasswordRequiresUniqueChars(options.RequiredUniqueChars));</span><br><span class="line">            &#125;</span><br><span class="line">            return</span><br><span class="line">                Task.FromResult(errors.Count == 0</span><br><span class="line">                    ? IdentityResult.Success</span><br><span class="line">                    : IdentityResult.Failed(errors.ToArray()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Returns a flag indicating whether the supplied character is a digit.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;c&quot;&gt;The character to check if it is a digit.&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;True if the character is a digit, otherwise false.&lt;/returns&gt;</span><br><span class="line">        public virtual bool IsDigit(char c)</span><br><span class="line">        &#123;</span><br><span class="line">            return c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Returns a flag indicating whether the supplied character is a lower case ASCII letter.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;c&quot;&gt;The character to check if it is a lower case ASCII letter.&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;True if the character is a lower case ASCII letter, otherwise false.&lt;/returns&gt;</span><br><span class="line">        public virtual bool IsLower(char c)</span><br><span class="line">        &#123;</span><br><span class="line">            return c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;z&apos;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Returns a flag indicating whether the supplied character is an upper case ASCII letter.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;c&quot;&gt;The character to check if it is an upper case ASCII letter.&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;True if the character is an upper case ASCII letter, otherwise false.&lt;/returns&gt;</span><br><span class="line">        public virtual bool IsUpper(char c)</span><br><span class="line">        &#123;</span><br><span class="line">            return c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;Z&apos;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Returns a flag indicating whether the supplied character is an ASCII letter or digit.</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;c&quot;&gt;The character to check if it is an ASCII letter or digit.&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;True if the character is an ASCII letter or digit, otherwise false.&lt;/returns&gt;</span><br><span class="line">        public virtual bool IsLetterOrDigit(char c)</span><br><span class="line">        &#123;</span><br><span class="line">            return IsUpper(c) || IsLower(c) || IsDigit(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>默认的实现类，除了实现了ValidateAsync方法，还有IsDigit IsLower等方法，他们对应了密码配置的属性，比如是否小写，是否大写等等…密码验证方法里面主要根据应用设置的密码强度属性来进行一次判断，代码比较好理解。</p><hr><h3 id="自定义实现密码强度验证"><a href="#自定义实现密码强度验证" class="headerlink" title="自定义实现密码强度验证"></a>自定义实现密码强度验证</h3><p>虽然内置的密码验证已经满足了大部分应用场景，但有的时候我们还是需要自定义实现一个满足自身业务需求的密码验证类。这里我给大家演示一下怎么去自定义个密码验证类去满足令人头疼业务需求。假设我们有这样一个业务需求：</p><ul><li>要求密码不能包含敏感字符：china<br>1.首先在项目中创建一个Infrastructure 文件夹，在该文件夹添加一个CustomPasswordValidator类，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">namespace DemoUser.Infrastructure</span><br><span class="line">&#123;</span><br><span class="line">    public class CustomPasswordValidator : PasswordValidator&lt;AppUser&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public override async Task&lt;IdentityResult&gt; ValidateAsync(</span><br><span class="line">            UserManager&lt;AppUser&gt; manager, AppUser user, string password)</span><br><span class="line">        &#123;</span><br><span class="line">            IdentityResult result = await base.ValidateAsync(manager,</span><br><span class="line">                user, password);</span><br><span class="line">            List&lt;IdentityError&gt; errors = result.Succeeded ? new List&lt;IdentityError&gt;() : result.Errors.ToList();</span><br><span class="line"></span><br><span class="line">            if (password.Contains(&quot;china&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                errors.Add(new IdentityError</span><br><span class="line">                &#123;</span><br><span class="line">                    Code = &quot;PasswordContainsillegalletter&quot;,</span><br><span class="line">                    Description = &quot;Password cannot contain china&quot;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return errors.Count == 0</span><br><span class="line">                ? IdentityResult.Success</span><br><span class="line">                : IdentityResult.Failed(errors.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.再次我们需要在startup类里面把我们自定义的密码验证类依赖注入到应用中，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            //注入自定义密码验证类</span><br><span class="line">            services.AddTransient&lt;IPasswordValidator&lt;AppUser&gt;,</span><br><span class="line">                CustomPasswordValidator&gt;();</span><br><span class="line">            </span><br><span class="line">            services.AddDbContext&lt;AppIdentityDbContext&gt;(options =&gt;</span><br><span class="line">                options.UseSqlServer(</span><br><span class="line">                    Configuration[&quot;Data:AppStoreIdentity:ConnectionString&quot;]));</span><br><span class="line">            //配置密码强度</span><br><span class="line">            services.AddIdentity&lt;AppUser, IdentityRole&gt;(opts =&gt; &#123;</span><br><span class="line">                    opts.Password.RequiredLength = 6;</span><br><span class="line">                    opts.Password.RequireNonAlphanumeric = false;</span><br><span class="line">                    opts.Password.RequireLowercase = false;</span><br><span class="line">                    opts.Password.RequireUppercase = false;</span><br><span class="line">                    opts.Password.RequireDigit = false;</span><br><span class="line">                &#125;).AddEntityFrameworkStores&lt;AppIdentityDbContext&gt;()</span><br><span class="line">                .AddDefaultTokenProviders();</span><br><span class="line">            services.AddMvc();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>这样我们的自定义的密码验证类就成功替换掉了内置的密码验证类。</li></ul><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>简单介绍了IPasswordValidator的配置和简单自定义，下一篇我打算讲解一下Identity架构的设计，以及我们可以自定义的地方有哪些。<br>代码对应的地址 <a href="https://github.com/bluetianx/AspnetCoreExample">github</a> 对应分支f3</p>]]></content>
      
      <categories>
          
          <category> Asp.net Core </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.net core Identity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/04/hello-world/"/>
      <url>/2018/04/04/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="Welcome-This-is-My-very-first-post"><a href="#Welcome-This-is-My-very-first-post" class="headerlink" title="Welcome ! This is My very first post."></a>Welcome ! This is My very first post.</h2><h3 id="你好，晓青！与君初相识，犹如故人归"><a href="#你好，晓青！与君初相识，犹如故人归" class="headerlink" title="你好，晓青！与君初相识，犹如故人归"></a>你好，晓青！与君初相识，犹如故人归</h3>]]></content>
      
      
    </entry>
    
  
  
</search>
